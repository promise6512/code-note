# 一.HTML&CSS
## 1. 请谈一谈什么是BFC
    BFC全称块级格式化上下文
    BFC特点：
    1)开启BFC可以防止子元素脱离文档流后(绝对定位/浮动)造成自身高度塌陷 
    2)开启BFC可以防止子元素与父元素外边距折叠
    开启BFC的方法:
    1)overflow的值设置为非visible
    2)设置float
    3)开启绝对定位 
    防止高度塌陷的最终解决方案
    设置如下样式：
    .clearfix::after{
        content: '';
        display: block;
        clear: both;
    }

## 2.谈一谈flex布局
    flex中文名字为弹性盒模型，是CSS中的一种布局手段，可以代替浮动。
    通过设置display:flex是元素成为弹性容器，其子元素为弹性模型
    弹性容器属性:
    flex-wrap：用于设置子元素是否自动换行
    flex-direction：用于设置子元素排列方式(定义主轴正方向)
    justify-content:设置主轴上空白分配
    align-content: 设置辅轴上空白分配
    align-items：设置辅轴上如何对其
    弹性元素属性：
    flex-grow：设置空间充足时的伸长系数
    flex-shrink:设置空间不足时的收缩系数
    align-self：可以覆盖align-items
## 3.box-sizing的属性和盒子模型
    CSS中的一个元素视为一个盒子，盒子包括内容区，内边距，边框和外边距。前三个加在一起是盒子的大小，外边距用于控制盒子之间的相对位置关系
    box-sizing定义了盒子大小的计算方式
    content-box: 设置的width和height仅代表内容区
    border-box:  设置的width和height代表内容区，内边距和边框三者之和，实际内容区大小=width-padding-margin
## 4.水平垂直居中的方法
## 5.position粘滞定位
    粘滞定位顾名思义,就好像是被黏贴在屏幕上了。具体表现为:即使滑动滚动条,元素在屏幕上的相对位置仍保持不变,可以对导航条和广告进行设置。
## 6.说一说position定位有哪些属性,有什么区别
    static:默认属性,不开启定位
    relative:相对定位,相对于开启定位前的位置进行定位,它会在原来的位置留下空白,因此不会改变页面布局。会提升元素层级
    absolute:绝对定位,开启后元素脱离文档流,相对于最近的非static的祖先元素定位
    fixed:固定定位,开启后元素脱离文档流,相对于屏幕视口定位,元素位置在屏幕滚动时不发生改变,当某个祖先元素的transform为非none时,则相对该祖先定位
    sticky:粘滞定位,相对于最近的滚动祖先(overflow为非visible)或最近块级祖先定位,滑动滚动条,元素在屏幕上的相对位置仍保持不变
    
# 二.JavaScript
## 1.什么是闭包
    在一个嵌套函数结构中，当内部函数调用了外部函数的变量时，就产生了闭包;外部函数的变量并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然保持对它的引用；将返回的内部函数设置为null可以销毁闭包
    闭包作用：
    延长函数局部变量的生命周期并向外暴露;
    闭包缺点:
    局部变量不能及时销毁，滥用闭包会过度占用内存
## 2.判断str
    js中的字符串分为字符串字面量和字符串对象,字符串字面量是通过加引号,或用String()产生的，而字符串对象是new String()产生的,
    当字符串字面量调用方法时，js会自动将它转换为字符串对象
## 3.实现flatten
## 4.this指向问题
## 5.说说原型链？实例和类的原型链关系？Function和Object的原型链关系
    原型分为显式原型和隐式原型,显式原型在类上，隐式原型在实例对象上,实例的隐式原型指向类的显式原型。
    子类型的原型为父类型的实例对象,原型链实际上表示了类的继承关系
## 6.var let const的区别
    1)var声明的是函数作用域,而let声明的是块级作用域,比如if,for语句块,块级作用域是函数作用域的子集,所以let的作用域更小
    2)let不允许对一个变量重复声明
    3)let声明不会在作用域内被提升
    4)let声明在全局作用域中不会变为window对象的属性
    const与let基本相同;区别在于const声明变量时必须同时进行初始化;const声明的变量无法进行修改;如果是对象,则可以修改属性
## 7.打印结果
## 8.说一下类的创建和继承
## 9.说一下事件冒泡
    事件冒泡是指后代元素中事件触发时,其祖先元素的相同事件也会触发。
    例如:
    我们点击了A元素,则相当于其所有祖先元素也被点击了
    可以在事件监听函数中设置event.cancelBubble=true来取消冒泡的向上冒泡
    利用这一原理可以进行事件的委派:
        若多个子元素需要监听相同的事件,则给它们共同的祖先绑定事件监听,当事件触发时,会冒泡到祖先元素,使事件监听的回调函数执行
## 10.事件的传播
    事件的传播分为三个阶段
    1.捕获阶段
        事件从根节点流向目标节点,在途经的DOM节点触发捕获事件,直到到达目标节点
    2.目标阶段
        事件到达目标节点,在目标节点上触发事件
    3.冒泡节点
        事件向根节点冒泡,依次触发事件
    如果希望事件在捕获阶段执行,可以将addEventListener的第三个参数设置为true
## 11.说一说JavaScript的垃圾回收机制
    变量会在占用一块内存,当确定了某个变量不再使用时,就会释放这块内存,执行垃圾回收的程序会周期性自动运行。垃圾回收有标记清理和计数清理两个策略。标记清理就是为不再使用的变量加上标记,程序会自动清楚带标记的变量;引用计数是对值被引用的次数进行计数,当一个值得被引用数为0时就会被回收,由于引用计数容易因为循环引用而导致一些垃圾不能被正确回收.
    如果垃圾不及时回收,可能会造成内存泄漏,导致服务器宕机
## 12.node与浏览器的区别
    1)在浏览器中大多时候做的是与DOM和其他Web平台API(如cookie)的交互,而nodejs中没有document和window等对象
    2)浏览器中存在兼容性问题,需要通过babel对js语言进行转换,而node中没有这个问题
    3)nodejs采用commonjs模块系统,而浏览器中采用ES模块标准
## 13 手写防抖函数和节流函数
# 三.React
## 1.key的作用
    key帮助React识别哪些元素改变了，拥有相同的key的元素在不同的渲染下保持不变，降低diffing的时间复杂度，通常利用数组map批量产生虚拟DOM的时候要求为每个DOM指定一个key属性，key的值要求是独一无二，一般最好指定一个由后端提供的id值
## 2.简述diffing算法
    在某一时间点调用render方法，会生成一颗由React元素生成的树。
    下次再render时会再次生成一棵树，React会首先比较两颗树的根节点，如果节点元素类型不同，会卸载原先的DOM节点，再根据新树重新装载DOM节点。
    如果两个根节点D元素相同，则仅更新并修改有改变的属性。
    然后对每个子树进行递归比较
    当递归比较DOM子元素时，会先比较元素的Key属性，具有相同key的元素不会进行卸载和重新装载，而只是移动位置

# 四.计算机网络与浏览器原理
## 1.HTTP常见状态码
    2xx 成功
    200 OK 请求正常处理
    3xx 重定向
    301 Moved Permanetnly 永久重定向,请求资源被分配了新的URI
    302 Found 临时重定向,请求资源被【暂时】分配了新的URI
    304 Not Modified 服务器允许请求,但因为发生的请求未满足条件
    4xx 客户端错误
    403 Forbidden 请求被拒绝
    404 Not Found 服务器上找不到资源
    5xx 服务器错误
    503 Service Unavailiable 服务器处于超负载或正在进行停机维护
## 2.什么是跨域
    所有支持JavaScript的浏览器都遵循同源策略;当浏览器和服务器的端口号、协议、域名三者存在(一个或多个)不同时，则浏览器请求被视为跨域请求。浏览器执行跨域请求后，会将服务器返回的数据丢弃。
## 3.进程和线程的区别
    进程:程序执行时所占用的一块内存空间
    线程:CPU调度的最小单位
    一个程序至少有一个进程，一个进程至少有多个线程
    老版IE是单进程;chrome,Firefox和新版IE(IE8及以上)是多进程
## 4.TCP与UPD的区别
    1.TCP面向连接,通信前要通过三次握手建立连接;UDP面向报文,直接传输报文，无需建立连接
    2.TCP提供可靠服务,具有重传机制,保证数据无丢失、无差错、无重复、按序到达;UDP不保证可靠交付
    3.TCP具有拥塞机制,在传输过程中能够进行流量控制;UPD对于何时发送的控制更为精细,传输速度更快,更利于实时通信
    4.TCP是一对一通信;UPD可以一对一、一对多、多对多通信
    5.TCP首部开销(20字节)比UPD(8字节)大
    因特网电话、视频会议这种能够容许少量分组丢失,追求实时性的应用运行在UDP上
    而电子邮件、Web应用、文件传输等不容许丢失的应用运行在TCP上
## 5.Jsonp跨域请求原理
    1).客户端事先定义好一个用于接收相应数据的函数(fn)
    2).客户端在html中创建script标签，将url伪装成标签的src，函数fn作为标签的一部分
    3).服务端接收到请求，返回一个(调用函数的js代码)，并将结果数据作为实参传入函数调用
    4).收到响应并自动执行(调用函数的js代码),也就是执行了提前定义好的回调函数，得到了相应的数据
    注:jsonp只能解决GET类型的ajax请求的跨域问题;是同步请求
## 6.XSS攻击
    跨站脚本攻击
    1)储存型XSS：恶意代码储存在数据库中,用户打开目标网站时,恶意代码拼接到HTML,HTML返回浏览器被执行后,恶意代码也被执行
    2)放射性XSS: 恶意代码隐藏在URL中,其余步骤同上
    3)DOM型XSS：恶意代码隐藏在URL中,用户点击之后,前端JS取出恶意代码并执行.这是由于js代码的漏洞造成的。
    防范XSS攻击的方法:
    cookie中设置httpOnly,js脚本将无法读取cookie信息
    对html充分转义
    主流前端框架,默认防御XSS
## 7.CSRF攻击
    用户登录user登录了A网站之后，在未登出的情况下访问危险网站B,这时B网站请求访问A网站,并且盗用user的cookie,伪装成user进行恶意操作,比如违法转账。
    防御:
        验证码,强制用户必须与应用进行交互;
        将cookie的sameSite属性设置为Strict或Lax
            Strict:
                Strict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求 目标一致，才会带上 Cookie。
            Lax:
                Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。
##  8.域名解析过程
    1)请求主机向本地DNS服务器发送查询报文
    2)本地DNS服务器将查询报文转发给根DNS服务器
    3)根服务器获取报文前缀,检索其对应的TLD(顶级域)DNS服务器的IP地址,并告返回
    4)本地DNS服务器向顶级域服务器发送查询报文;
    5)顶级域DNS服务器返回权威DNS服务器的IP
    6)本地DNS服务器向权威DNS服务器发送查询报文;
    7)权威DNS服务器解析域名返回目的主机的IP地址
    8)本地DNS服务器将目的主机的IP地址返回给请求主机
## 9.IPv4和IPv6的区别
    1)IPv4地址长度为32比特,IPv6地址长度为128比特
    2)IPv6的数据报结构更加简单、高效,去除了选项字段,成为定长的40字节;
    3)IPv6不允许在不允许在中间路由器进行分片和重新组装,这种操作只能在源和目的地进行
    4)IPv6去除了首部检验和功能
## 10.HTTP2.0特点
    1)采用二进制格式,使用方便且健壮
    2)多路复用,即单个连接上同时进行多个业务单元数据的传送
    3)多个请求可以在一个连接上并行执行
    4)压缩头部,大大降低了延迟
    5)服务端推送,服务端能够把客户端所需要的重要资源推送过去,加快速度
    6)拥有优先级策略,服务器对不同请求按照预先设定的优先级进行处理.
    7)连接是永久的,而且仅需要每个来源一个连接
    8)流控制:阻止发送方向接收方发送大量数据的机制
## 11.简述三次握手和四次挥手
    1)客户端向服务器发送SYN报文段,另外,会随机选择一个初始化序列号放入报文段中;
    2)服务器接收到SYN报文段后,为TCP连接分配缓存和变量,发送SYNACK报文段,该报文段中包含服务端随机生成的初始化序列号,
    3)客户端收到SYNACK报文段后,也会TCP连接分配缓存和变量,并回复一个确认报文。
    四次挥手:
        参与连接的两个进程中的任意一个都能终止该连接,假设客户端要终止连接,则发送一个特殊的TCP报文段,该报文段的FIN字段被设置为1,服务端收到后,先发送确认报文,在发送终止报文,客户端收到终止报文后,在发送确认报文.最后连接断开
## 12.POST和GET的区别
    1)get支持url编码,post支持多种编码
    4)get参数放在url中,post参数放在request body里面,因此post更安全
        get将参数直接暴露在url中,不能用来传递敏感数据
    3)get请求会被浏览器主动缓存,而post不会,除非手动设置
    4)get请求参数会被保存在浏览器历史记录里面,而get不会
    5)get提交请求数据,post提高要被处理的数据
    6)get产生一个TCP数据包,post产生两个TCP数据包
        对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）;而对于POST，浏览器先发header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
    提交表单数据 https://www.cnblogs.com/miluluyo/p/11196672.html
    1)get从服务器上获取数据,post向服务器推送数据
    2)get将参数放在表单action所指url中,用户可以看到;post将字段和内容放在html header中,用户看不到
    3)get通过Requset.QueryString获取数据;post通过Request.Form获取数据
    4)get传送的数据量小,不能超过2kb;post传送的数据量一般认为没有限制
    5)get安全性低;post安全性高
## 13.谈一谈对websocket的理解
    websocket是一种基于tcp的全双工通信协议.http2.0版本之前有一种缺陷:通信只能由客户端发起,如果服务端频繁更新数据(如聊天室),那么客户端就要通过轮询的方式不断发起请求以获取实时信息,这种轮询的效率非常低,而websocket支持双方互相发起通信,弥补了了这一缺陷.
    websocket建立过程:
        握手阶段使用http协议,有客户端发起,握手成功后切换为websocket协议,此时服务端可以直接推送信息.