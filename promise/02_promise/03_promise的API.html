<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>06_Promise的API</title>
</head>

<body>

    <script>

        /* 
          1. Promise构造函数: Promise (excutor) {}
              excutor函数: 同步执行  (resolve, reject) => {}
              resolve函数: 内部定义成功时我们调用的函数 value => {}
              reject函数: 内部定义失败时我们调用的函数 reason => {}
              说明: excutor会在Promise内部立即同步回调,异步操作在执行器中执行
      
          2. Promise.prototype.then方法: (onResolved, onRejected) => {}
              onResolved函数: 成功的回调函数  (value) => {}
              onRejected函数: 失败的回调函数 (reason) => {}
              说明: 指定用于得到成功value的成功回调和用于得到失败reason的失败回调
                    返回一个新的promise对象
      
          3. Promise.prototype.catch方法: (onRejected) => {}
              onRejected函数: 失败的回调函数 (reason) => {}
              说明: then()的语法糖, 相当于: then(undefined, onRejected)
      
          4. Promise.resolve方法: (value) => {}
              value: 成功的promise对象
              说明: 返回一个成功的promise对象
      
          5. Promise.reject方法: (reason) => {}
              reason: 失败的原因
              说明: 返回一个失败的promise对象
      
          6. Promise.all方法: (promises) => {}
              promises: 包含n个promise的数组
              说明: 返回一个新的promise, 只有所有的promise都成功才成功, 只要有一个失败了就直接失败

          7. Promise.race方法: (promises) => {}
              promises: 包含n个promise的数组
              说明: 返回一个新的promise, 第一个完成的promise的结果状态就是最终的结果状态
        */
        /* new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('成功的数据')
            })
        }).then(
            value => {
                console.log('onResolved()1')
            }
        ).catch(
            reason => {
                console.log('onRejected()1')
            }
        ) */

        //产生一个成功值为1的promise对象
        const p = new Promise((resolve, reject) => {
            setTimeout(()=>{
                resolve(0)
            },1000)
        })
        //简化写法
        const p1 = Promise.resolve(1)

        //产生一个失败值为2的promise对象
        const p2 = Promise.reject(2);

        const p3 = Promise.reject(3);
        p1.then(value => { console.log('value的值是' + value) })
        p2.catch(reason => { console.log('reason的值是' + reason) })
        
        //传入一个包含若干个promise的数组,并返回一个新的promise
        const pAll = Promise.all([p1, p, ])
        //新的promise成功的结果为参数数组中所有promise成功值构成的数组
        pAll.then(
            values => {
                //values为成功的值构成的数组
                console.log('all onResolved()',values)
            },
            reason => {
                //返回失败的值
                console.log('all onRejected()', reason)
            }
        )
         
        //p设定了延迟 p1为率先完成的promise 所以pRace的状态由p1决定
        const pRace = Promise.race([p, p1, p2, p3])
        pRace.then(
            values => {
                console.log('race onResolved',values)
            },
            reason => {
                console.log('race onRejected()', reason)
            }
        )
    </script>
</body>

</html>